Editor Server
============

Architecture
--------
This is a high level architecture of editor service. Grey arrow represents user API, green arrow represents data flow/dependencies inside the implementation of editor service. Blue line is the API boundary, user visible space is to the left of the blue line, right side is implementation details.

.. image:: images/arch.png
  :align: center

Terminology
--------

* **Editor Server**: A cluster of machines that directly manage user workspaces and interact with build server and database to handle build and metadata requests from editor client.

* **Build Server**: A cluster of machines that will perform build on a version of a workspace and request the generated metadata to be saved into database.

* **MongoDB**: A document based key-value store that serves as persistent storage in the system.
* **Elastic Search**: A search server based on Lucene.

* **Workspace**: A source code project that is self-contained and belongs to a specific user.

* **Metadata**: Extra information, such as Node and Edge, generated by build server that will be used to decorate text source code content for functionalities like jump to definition.

API
--------
The API use JSON as request and response payload for uniformity.  The name of parameter or response is the key of the JSON object.


GET /projects/$projectId
~~~~~~~~

**Summary**: This returns the projectInfo and build status of the project specified by ``$projectId``.

**Parameter**:

* project_id: unique identifier of the workspace in editor server.

**Response**:

* [200 Ok] an object representing the projectInfo of the project.
.. image:: images/projects.png
  :align: center
  :width: 400

* [404 Not Found] (if projectId is not found)


DELETE /projects/$projectId
~~~~~~~~

**Summary**: This deletes a workspace in Editor Server, note that this only deletes everything in editor server does not affect underlying workspace.

**Parameter**:

* project_id: unique identifier of the workspace in editor server to be deleted

POST /projects/$projectPath
~~~~~~~~

**Summary**:
This creates a workspace in Editor Server and allocate necessary resource for further user interaction(query metadata, rebuild metadata). Each workspace in Editor Server should map to an existing underlying workspace.

**Parameter**:

* projectPath: The path of the underlying workspace relative to the root path, e.g. dw/dwx299268/OrionContent/org-eclipse-orion-client.

**Response**:

* [200 Ok] project_id: unique identifier of the workspace in editor server
* [201 Ok] project_id: unique identifier of the workspace in editor server (if projectPath has been initiated before)
* [404 Not Found] (if projectPath is not found)

POST /analyze/$projectId?image=$imageName
~~~~~~~~

**Summary**:
It triggers a rebuild of the project based on a snapshot of the project source at the time of request. The server will re-analysis all files and, and store the metadata and the file content into database. whenever the workspace needs a fully rebuild, call this API.

**Parameter**:

* projectId: the unique identifier of the project
* imageName: the docker image name that is going to be used to do analysis
* file: the particular file that need to be analyzed so no need to analyze the whole project

**Body**:
  * cmd: the command that need to be run before build, it shouldn't end with white space.

.. code-block:: json

  {
     cmd: $script
  }

**Response**:

* [200 Ok] medata_version: an integer represents the age of metadata
* [404 Not Found] (if projectId does not exist)

GET /metadata/$projectId/$filePath
~~~~~~~~

**Summary**
the server will diff the current file content and the file content in the database, and compute the metadata that for the file. Note that no rebuild will be triggered through this API, all metadata change is generated by text-based diff.
Note: The client might want to compute metadata diff in order to render the web page in more efficient way.

**Parameter**:

* projectId: unique identifier of the project in editor server
* filePath: the file in interest

**Response**:

* [200 Ok] object that contains the metadata (nodes, edges, content and fileLocation) of this file

.. image:: images/metadata.png
  :align: center
  :width: 400

* [404 Not Found] (if projectId or filePath does not exist)

GET /node/$projectId/$signature
~~~~~~~~

**Summary**:
Query metadata for a specific node

**Parameter**:

* projectId: unique identifier of the project in editor server
* signature: the signature of the node

**Response**:

* [200 Ok] node object of the given signature

.. image:: images/node.png
  :align: center
  :width: 400

* [404 Not Found] (if projectId or signature does not exist)


GET /references/$projectId/$signature
~~~~~~~~

**Summary**:
Query metadata for a specific node

**Parameter**:

* projectId: unique identifier of the project in editor server
* signature: the signature of the node

**Response**:

* [200 Ok] references: object that contains the references of the node

.. image:: images/references.png
  :align: center
  :width: 500

* [404 Not Found] (if projectId or signature does not exist)

GET /debugInfo/$projectId
~~~~~~~~

**Summary**:
Get the debug information of the given project (currently contains log and jenkins builder URL)

**Parameter**:
* projectId: unique identifier of the project in editor server

**Response**:

* [200 Ok] object that contains the debug information
.. image:: images/debugInfo.png
  :align: center
  :width: 400

* [404 Not Found] (if projectId does not exist)

POST /searchIndex/$projectId
~~~~~~~~

**Summary**:
Build(or rebuild) search index for project with projectId, it will be automatically trigged by jenkins job.

This API is supposed to be invoked by builder after the build is finished, rather than invoked by user.

**Parameter**:

* projectId: a project identified by projectId

**Response**:

* [200 Ok] search index has started to build. Note that to check if search index building is successful or not, use index_status field of the response of [GET /projects/$projectId] and.
* [404 Not Found] (if projectId does not exist)

GET /datum
~~~~~~~~

**Summary**:
Search a node given a query string, optionally within a project

**Parameter**:

* q: the query string, e.g. “java.lang.string”
* projectId: search within a project identified by projectId

**Response**:
* [200 Ok] An object contains the list of nodes

Project Level Configuration
--------
Some times editor server can't correctly infer the build command, which will result in less accurate index. In order to improve the result, one could put a simple 'lambda.yml' file
under project's root directory which following format:

.. code-block:: yaml

  checkout:
    override:
      - git submodule sync
      - git submodule update --init

  dependencies:
    override:
      - sudo apt-get install python-sphinx
      - sudo apt-get install nodejs

  build:
    override:
      - TERM="dumb" make

checkout section have the extra steps of check out repositories, dependencies section have the extra step to download dependencies, and the build section contains the most important
information, that is how to actually build the project.